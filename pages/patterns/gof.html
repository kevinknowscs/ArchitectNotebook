<!DOCTYPE html>
<html>
<head>
  <title>.NET Notebook</title>
  <script type="text/javascript">
    globals = { baseUrl: '../..' };
  </script>

  <script type="text/javascript" src="../../scripts/polyfill.js"></script>
  <script type="text/javascript" src="../../scripts/helpers.js"></script>
  <script type="text/javascript" src="../../scripts/dom.js"></script>
  <script type="text/javascript" src="../../scripts/search.js"></script>
  <script type="text/javascript" src="../../scripts/toc.js"></script>

  <link rel="stylesheet" type="text/css" href="../../css/layout/notebook1.css" />
  <link rel="stylesheet" type="text/css" href="../../css/themes/blue.css" />
  <link rel="stylesheet" type="text/css" href="../../css/content/standard.css" />

  <style type="text/css">
    table.templates td:first-child {
      width: 200px;
    }

    table.templates td:nth-child(2) {
      width: 190px;
    }
  </style>
</head>
<body>
  <div class="outer-layout">
    <div class="north-pane">
      <div class="north-left-pane">
        <div class="logo-area">
          <div class="logo">
            .NET Developer Notebook
          </div>
        </div>
      </div>
      </section>
      <div class="north-right-pane">
        <div class="search-outer-area">
          <input type="text" id="searchTextBox" placeholder="Search ...">
        </div>
      </div>
    </div>
    <div class="south-pane">
      <div class="south-left-pane">
        <div class="sidebar-area">
        </div>
      </div>
      <div class="south-right-pane">
        <div class="page-area">
          <div class="page-title-area">
            <div id="page-title-id" class="page-title">
              Basic Design Patterns
            </div>
          </div>
          <div id="page-content-scroller-id" class="page-content-scroller">
            <div id="page-content-id" class="page-content">
              <table>
                <tr>
                  <th>Pattern Name</th>
                  <th>Description</th>
                  <th>Links</th>
                </tr>
                <tr class="category">
                  <td colspan="3">Creational Patterns</td>
                </tr>
                <tr>
                  <td>Abstract Factory</td>
                  <td>
                    Define an interface for creating a family of related or
                    dependent objects without specifying their concrete class names.
                  </td>
                  <td><a href="https://www.dofactory.com/net/abstract-factory-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>Builder</td>
                  <td>
                    Separate the construction of a complex object from its representation
                    so that the same construction process can create different representations.
                  </td>
                  <td><a href="https://www.dofactory.com/net/builder-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>Factory Method</td>
                  <td>
                    Define an interface for creating an object, but let subclasses decide which class to
                    instantiate (i.e., defer instantiation to subclasses).
                  </td>
                  <td><a href="https://www.dofactory.com/net/factory-method-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>Prototype</td>
                  <td>
                    Specify the kinds of objects to create using a prototypical instance, and create new
                    objects by copying this prototype.
                  </td>
                  <td><a href="https://www.dofactory.com/net/prototype-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>Singleton</td>
                  <td>
                    Ensure a class only has one instance, and provide a global point of access to it.
                  </td>
                  <td><a href="https://www.dofactory.com/net/singleton-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr class="category">
                  <td colspan="3">Structural Patterns</td>
                </tr>
                <tr>
                  <td>Adapter</td>
                  <td>
                    Convert the interface of a class into another interface clients expect, thereby
                    letting classes work together that couldn't otherwise because of incompatible
                    interfaces.
                  </td>
                  <td><a href="https://www.dofactory.com/net/adapter-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>Bridge</td>
                  <td>
                    Decouple an abstraction from its implementation so that the two can vary independently.
                  </td>
                  <td><a href="https://www.dofactory.com/net/bridge-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>Composite</td>
                  <td>
                    Compose objects into tree structures to represent part-whole hierarchies, thus
                    letting clients treat a group of objects the same as individual objects.
                  </td>
                  <td><a href="https://www.dofactory.com/net/composite-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>Decorator</td>
                  <td>
                    Attach additional reposibilities to an object dynamically, providing a flexible
                    alternative to subclasses.
                  </td>
                  <td><a href="https://www.dofactory.com/net/decorator-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>Facade</td>
                  <td>
                    Make a subsystem easier to use by providing a higher-level, unified interface
                    to a set of interfaces in a subsystem.
                  </td>
                  <td><a href="https://www.dofactory.com/net/facade-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>Flyweight</td>
                  <td>
                    Use sharing to support large numbers of fine-grained objects efficiently.
                  </td>
                  <td><a href="https://www.dofactory.com/net/flyweight-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>Proxy</td>
                  <td>
                    Provide a surrogate or placehold for another object to control access to it.
                  </td>
                  <td><a href="https://www.dofactory.com/net/proxy-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr class="category">
                  <td colspan="3">Behavioral Patterns</td>
                </tr>
                <tr>
                  <td>Chain of Responsibility</td>
                  <td>
                    Avoid coupling the sender of a request to its receiver by giving more than one
                    object a chance to handle the request. Chain the receiving objects and pass the
                    request along the chain until an object handles it.
                  </td>
                  <td><a href="https://www.dofactory.com/net/chain-of-responsibility-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>Command</td>
                  <td>
                    Encapsulate a request as an object, thereby letting you parameterize clients with
                    different requests, queue or log requests, and support undoable operations.
                  </td>
                  <td><a href="https://www.dofactory.com/net/command-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>Interpreter</td>
                  <td>
                    Given a language, define a representation for its grammar along with an interpreter
                    that uses the representation to interpret sentences in the language.
                  </td>
                  <td><a href="https://www.dofactory.com/net/interpreter-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>Iterator</td>
                  <td>
                    Provide a way to access the elements of an aggregate object sequentially without
                    exposing its underlying representation.
                  </td>
                  <td><a href="https://www.dofactory.com/net/iterator-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>Mediator</td>
                  <td>
                    Define an object that encapsulates how a set of objects interact. Mediator promotes
                    loose coupling by keeping objects from referring to each other explicitly, at it lets you
                    vary their interaction independently.
                  </td>
                  <td><a href="https://www.dofactory.com/net/mediator-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>Memento</td>
                  <td>
                    Without violating encapsulation, capture and externalize an object's internal state
                    so that the object can be restored to this state later.
                  </td>
                  <td><a href="https://www.dofactory.com/net/memento-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>Observer</td>
                  <td>
                    Define a one-to-many dependency between objects so that when one object changes state,
                    all its dependents are notified and updated automatically.
                  </td>
                  <td><a href="https://www.dofactory.com/net/observer-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>State</td>
                  <td>
                    Allow an object to alter its behavior when its internal state changes. The object will
                    appear to change its class.
                  </td>
                  <td><a href="https://www.dofactory.com/net/state-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>Strategy</td>
                  <td>
                    Define a family of algorithms, encapsulate each one, and make them interchangeable.
                    Strategy lets the algorithm vary independently from clients that use it.
                  </td>
                  <td><a href="https://www.dofactory.com/net/strategy-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>Template Method</td>
                  <td>
                    Define the skeleton of an algorithm in an operation, deferring some steps to subclasses.
                    Template Method lets subclasses redefine certain steps of an algorithm without changing
                    the algorithm's structure.
                  </td>
                  <td><a href="https://www.dofactory.com/net/template-method-design-pattern" target="_blank">C#</a></td>
                </tr>
                <tr>
                  <td>Visitor</td>
                  <td>
                    Represent an operation to be performed on the elemnts of an object structure. Visitor
                    lets you define a new operation without changing the classes of elements on which it
                    operates.
                  </td>
                  <td><a href="https://www.dofactory.com/net/visitor-design-pattern" target="_blank">C#</a></td>
                </tr>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</body>
</html>
